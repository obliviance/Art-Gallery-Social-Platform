# Art-Gallery-Social-Platform
A social platform for sharing and engaging with artworks, built using JavaScript with Express, MongoDB and Mongoose. 

## Start Server
In order to run the server, Node.js and MongoDB must be installed on the computer. Both programs are free and tutorials for installation can be found online.

In order to start the server you will need to first ensure that the mongoDB server is running. This can be determined by using Task Manager on Windows(it won’t be in the first couple tasks). Once you’ve ensured the mongo server is running, you can open a terminal in the main directory. You can then type in the command `npm install` and press enter, which will install all modules and dependencies. Next, you need to type in `node database-initializer.js` and press enter. This will initialize the mongoDB database and populate the collections. Finally, type in `node server.js` and press enter. You should see a message in the terminal ending in `Server listening at localhost:3000`. You can then open a new tab in your browser and type in `localhost:3000` in your search bar. Pressing enter will take you to the application webpage.

## Overall Design and Implementation
In this project I attempted to follow some of the RESTful design principles. One principle I followed was the separation of client and server. The client is largely HTML files and client JS files which send requests and make small local changes to the webpage. Statelessness was a RESTful design principle I was not able to maintain, as the desire to have user sessions required session data to be stored on a server, which creates a dependency on the current configuration. Additionally, caching was not really implemented in the application either. Caching would have resulted in fewer needless changes to the website pages, and would have likely allowed for fewer requests overall. Specific content that would have been useful to be cached would be the logged in user’s object and client JS files. In terms of implementing a uniform interface, I believe that I have established the manipulation of resources through representations, self-descriptive messaging, and HATEOAS(hyperlink usage). However, some resources are not correctly labelled, like profile, which should ideally be “user/userID”, perhaps with some notifier that it’s the current user. For that reason I would say that I only mostly followed the identification of resources sub principle. My system is layered as there is a division between the client, the server, and the database, which each interact through their own APIs. 

I used HTTP status codes as necessary to inform the client of changes made to the database and other general changes. I believe that I handled the simple errors that bear testing for a project of this complexity. Most of my relevant functions were also asynchronous. As previously stated, caching and not repeating requests would have minimized data transfer, and I believe some requests could have been avoided as a rule by storing frequently accessed information on the client. 

## Design Decisions
My design was very rudimentary and simple, essentially completing what was necessary and leaving the rest. There were no significant design decisions due to the lacking display of the application. One might say the design was "in the style of web applications in the late 1900s".
